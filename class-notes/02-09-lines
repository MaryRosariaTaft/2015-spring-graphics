Think in octants.

m = slope

Octant I: 0 < m <= 1
Octant II: 1 < m <= infinity
etc.

---

Jack Elton Bresenham developed this line algorithm in 1962 while at IBM.

Given two endpoints (x_0, y_0) and (x_1, y_1) where all coordinates are integers, draw a line.

y = (dy/dx)*x + b
(dx)*y = (dy)*x + (dx)*b
0 = (dy)*x - (dx)*y + (dx)*b

let:
A = dy
B = -dx
C = dx*b

0 = Ax + By + C

then make it a function of x and y:

f(x, y) = Ax + By + C

if f(x, y) == 0, then (x, y) falls on the line
if f(x, y) < 0, then (x, y) falls above the line
if f(x, y) > 0, then (x, y) falls below the line

Here's the algorithm FOR OCTANT I:

x = x_0
y = y_0

while(x <= x_1)
	plot(x, y)
	d = f(x+1, y+.5) //the midpt. of the two next pixels to be checked, (x+1, y) and (x+1, y+1)
	x++
	if(d > 0)
	     y++

---

Now, to write f(x, y) such that we can solve for d.

initial value:

d = f(x_0 + 1, y_0 + .5)
  = A*(x_0 + 1) + B*(y_0 + .5) + C
  = A*x_0 + A + B*y_0 + .5*B + C
  = [A*x_0 + B*y_0 + C] + A + .5*B
  = [f(x_0, y_0)] + A + .5*B
  = 0 + A + .5*B

ahh...

let d_i = f(x_i, y_i)

if(d_i > 0)
       d_(i+1) = d_i + A + B
if(d_i < 0)
       d_(i+1) = d_i + A

---

A better algorithm:

x = x_0
y = y_0
d = A + .5*B

while(x <= x_1)
	plot(x, y)
	if(d > 0)
	     y++
	     d += B
	x++
	d += A